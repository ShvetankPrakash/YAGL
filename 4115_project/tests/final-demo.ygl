/* Social Media Application */

Graph fb;        /* Facebook  */
Graph tw;        /* Twitter   */
Graph ln;        /* LinkedIn  */

/* People */
Node adam("Adam");
Node james("Jamie");                                                         /* Typo on purpose for demonstration later */
Node jack("Jack");
Node tank("Shvetank");
Node edwards("Edwards");
Node tiffany("Tiffany");
Node buehler("Buehler");
Node michael1("Michael1");
Node michael2("Michael2");




/* Add people to Facebook's network */
fb: + adam + james + jack + tank;

/* Add edges between people to make them friends */
fb: adam <-> james <-> jack, tank <-> jack, tank <-> adam;                   /* Facebook friends is a bidirectional relationship */

printString("Facebook's Network");
printGraph(fb);




/* Add people to Twitter's network and edges between them to add follwers */
tw: + edwards + michael1 -> edwards,     /* Twitter followers is a one directional relationship (not required to follow back) */ 
    + michael2 + tank <- edwards;        /* Nodes can be in multiple graphs */   

printString("Twitter's Network");
printGraph(tw);




/* Add people to LinkedIn's graphs and edges between people to make connections, LinkedIn connections are bidirectional */
ln: + tiffany + buehler + james + edwards + michael1 + michael2 + adam + tank <-> james <-> adam <-> edwards <-> michael1 <-> michael2 <-> tiffany <-> edwards,
    + jack, buehler <-> james <-> jack;

printString("LinkedIn's Network");
printGraph(ln);

/* Delete the random people from LinkedIn since they chose to delete their accounts */
ln: - tiffany - buehler - michael2 - michael1;

printString("LinkedIn's Network");
printGraph(ln);

/* Update typo! fixes in all graphs */
james = "James";
printGraph(ln);

/* TAKE THINGS FROM BELOW AND IMPLEMENT TO GET BFS WORKING */

/* Find friends of friends */
dfs_call(fb, james, 2);           /* Should find tank */
print(fb);


void dfs_helper(Graph g, Node vertex, int depth){
   if (vertex.visited == true) {
       return;
   }
   if (vertex.curr_dist > depth) {
       return;
   }
   vertex.visited = true;

   /* Do whatever you want to the vertex */
   if (vertex.curr_dist == 0) {
   } else {
   	print(vertex);
   }

   int size = g.num_neighbors[vertex];
   int curr = 0;

   while (curr < size) {
      Node current;
      current = g.neighbor[vertex, curr];
      if (current.curr_dist == 0) {
          current.curr_dist = vertex.curr_dist + 1;
      }
      curr = curr + 1;
   }
   curr = 0;
   while (curr < size) {
      Node current;
      current = g.neighbor[vertex, curr];
      /*print(g.weight[current, vertex]);*/
      dfs_helper(g, current, depth);
      curr = curr + 1;
   }
}

void reset(Graph g) {
    int size = g.num_nodes;
    int curr = 0;

    while (curr < size) {
      Node current;
      current = g.node[curr];
      current.visited = false;
      current.curr_dist = 0;
      curr = curr + 1;
    }
}

void dfs_call(Graph g, Node vertex, int depth) {

	reset(g);
	dfs_helper(g, vertex, depth);

}
